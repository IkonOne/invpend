#include "Peer.h"
#include "Protocol.h"
#include "PacketBuilder.h"
#include <assert.h>
#include <string.h> // memset()

using namespace std;

namespace iplib {
namespace net {

template <typename TConnection>
Peer<TConnection>::Peer(TConnection &connection, int maxPacketSize, unsigned short protocolID)
    : _connection(connection),
        _protocolID(protocolID),
        _protocolIDHead(protocolID >> 8),
        _protocolIDTail(protocolID & 0x00FF),
        _lastProtocolChar(~_protocolIDHead),
        _readBuff(new unsigned char[maxPacketSize])
{
    assert(_protocolIDHead != _protocolIDTail);
}

template <typename TConnection>
Peer<TConnection>::~Peer() {
    if (_readBuff) delete[] _readBuff;
}

template <typename TConnection>
void Peer<TConnection>::WriteHeader(unsigned char packetType) {
    _header.pid = _protocolID;
    _header.sid = _connectionID;
    _header.sequence = _sequence++;
    _header.ack = _ack;
    _header.ackBitmask = _ackBitmask;
    _header.type = packetType;
    _header.dataSize = GetPacketSize(packetType);
    _header.WriteTo(_txBuilder);
}

template <typename TConnection>
void Peer<TConnection>::WriteChecksum() {
    checksum_t checksum = _txBuilder.GetChecksum();
    _txBuilder.Write(checksum);
}

template <typename TConnection>
bool Peer<TConnection>::ReadProtocol() {
    unsigned char readChar;

    if (_readState > READ_STATE_PKT)
        return true;

    while (0 != _connection.Receive(&readChar, 1)) {
        // This assumes that both bytes of the protocolID are unique
        // which is asserted in the constructor.
        if (_protocolIDHead == readChar) {
            _lastProtocolChar = readChar;
        }
        else if (_lastProtocolChar == _protocolIDHead && readChar == _protocolIDTail) {
            _rxBuilder.Reset();
            _rxBuilder.Write(_protocolID);
            _readState++;
            return true;
        }
        else {
            _lastProtocolChar = readChar;
        }
    }

    return false;
}

template <typename TConnection>
bool Peer<TConnection>::ReadHeader() {
    static constexpr int headerSize = packet_header_t::GetSize();

    if (_readState > READ_STATE_HEAD)
        return true;

    int bytesReceived = _connection.Receive(_readBuff, headerSize - _rxBuilder.GetSize());
    _rxBuilder.WriteRaw(_readBuff, bytesReceived);

    if (_rxBuilder.GetSize() < headerSize)
        return false;

    _readState++;
    return true;
}

template <typename TConnection>
bool Peer<TConnection>::ReadPacket() {
    static constexpr int headerSize = packet_header_t::GetSize();

    if (_readState > READ_STATE_PKT)
        return true;
    
    int bytesReceived = _connection.Receive(_readBuff, _header.dataSize + headerSize - _rxBuilder.GetSize());
    _rxBuilder.WriteRaw(_readBuff, bytesReceived);

    if (_rxBuilder.GetSize() < _header.dataSize + headerSize)
        return false;
    
    _readPktCRC = _rxBuilder.GetChecksum();
    _readState++;
    return true;
}

template <typename TConnection>
bool Peer<TConnection>::ValidateChecksum() {
    if (_readState > READ_STATE_CHECKSUM)
        return true;
    
    int bytesReceived = _connection.Receive(_readBuff, sizeof(checksum_t) - _checksumBytes);
    _checksumBytes += bytesReceived;

    if (_checksumBytes < sizeof(checksum_t))
        return false;
    
    if ((checksum_t)_readBuff != _readPktCRC) {
        ResetReceive();
        return false;
    }

    return true;
}

template <typename TConnection>
void Peer<TConnection>::ResetReceive() {
    _lastProtocolChar = ~_protocolIDHead;
    _readState = READ_STATE_PROTO;
    _checksumBytes = 0;
    _readPktCRC = 0;
    _rxBuilder.Reset();
}

template <typename TConnection>
bool Peer<TConnection>::IsPacketReady() {
    if (!ReadProtocol()) return false;
    if (!ReadHeader()) return false;
    if (!ReadPacket()) return false;
    return ValidateChecksum();
}

}   //  net
}   //  iplib